{"remainingRequest":"C:\\Users\\JThorneUMN\\Documents\\GitHub\\dendro-plots\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\JThorneUMN\\Documents\\GitHub\\dendro-plots\\src\\modules\\formatFileData.js","dependencies":[{"path":"C:\\Users\\JThorneUMN\\Documents\\GitHub\\dendro-plots\\src\\modules\\formatFileData.js","mtime":1630610638435},{"path":"C:\\Users\\JThorneUMN\\Documents\\GitHub\\dendro-plots\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\JThorneUMN\\Documents\\GitHub\\dendro-plots\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gIkM6L1VzZXJzL0pUaG9ybmVVTU4vRG9jdW1lbnRzL0dpdEh1Yi9kZW5kcm8tcGxvdHMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IiOwppbXBvcnQgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIgZnJvbSAiQzovVXNlcnMvSlRob3JuZVVNTi9Eb2N1bWVudHMvR2l0SHViL2RlbmRyby1wbG90cy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCAicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnBhcnNlLWZsb2F0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5wYXJzZS1pbnQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzIjsKLy8gcGFyc2UgbG9jYWwgY29yZSBwb2ludHMgaW4gTFRyZWVyaW5nCi8vIHdpbmRvdy5wb3N0TWVzc2FnZSh7IHg6IFtdLCB5OiBbXSwgbmFtZTogIiIgfSkKLy8gdXNlIGRpc3RhbmNlICYgYW5ub3RhdGlvbiBkYXRhIGluIEpTT04KaW1wb3J0IFBhcGEgZnJvbSAncGFwYXBhcnNlJzsKCmZ1bmN0aW9uIHRvTU0obnVtKSB7CiAgaWYgKG51bS5sZW5ndGggPT0gNCkgewogICAgLy8gMTIzNCA9PiAxLjIzNAogICAgcmV0dXJuIG51bS5zbGljZSgwLCAxKSArICcuJyArIG51bS5zbGljZSgxKTsKICB9IGVsc2UgaWYgKG51bS5sZW5ndGggPT0gMykgewogICAgLy8gMTIzID0+IDAuMTIzCiAgICByZXR1cm4gJzAuJyArIG51bTsKICB9IGVsc2UgaWYgKG51bS5sZW5ndGggPT0gMikgewogICAgLy8gMTIgPT4gMC4wMTIKICAgIHJldHVybiAnMC4wJyArIG51bTsKICB9IGVsc2UgewogICAgLy8gMSA9PiAwLjAwMQogICAgcmV0dXJuICcwLjAwJyArIG51bTsKICB9Cn0KCmZ1bmN0aW9uIGZvcm1hdFJXTChkYXRhKSB7CiAgdmFyIGZvcm1hdHRlZERhdGEgPSBbXTsgLy8gMSkgcndsIHJlbW92ZSBoZWFkZXIKCiAgdmFyIGhlYWRlckxlbmd0aCA9IDA7CgogIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhKSwKICAgICAgX3N0ZXA7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykgewogICAgICB2YXIgX2FycmF5ID0gX3N0ZXAudmFsdWU7CgogICAgICB2YXIgdGVzdF9jaGFyYWN0ZXIgPSBfYXJyYXlbMF0uY2hhckF0KDkpOwoKICAgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQodGVzdF9jaGFyYWN0ZXIpKSkgewogICAgICAgIGhlYWRlckxlbmd0aCsrOwogICAgICB9IGVsc2UgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3IuZShlcnIpOwogIH0gZmluYWxseSB7CiAgICBfaXRlcmF0b3IuZigpOwogIH0KCiAgZGF0YS5zcGxpY2UoMCwgaGVhZGVyTGVuZ3RoKTsgLy8gMikgc3BsaXQgcndsIGRhdGEgaW50byBhcnJheQogIC8vIGN1cnJlbnQgZm9ybWF0OiBbQ29yZSBuYW1lLCB5ZWFyLCBsZW5ndGgsIGxlbmd0aCwgbGVuZ3RoLCAuLi5dLCAuLi4KCiAgdmFyIHJ3bFNwbGl0RGF0YSA9IFtdOwoKICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEpLAogICAgICBfc3RlcDI7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykgewogICAgICB2YXIgX2FycmF5MiA9IF9zdGVwMi52YWx1ZTsKCiAgICAgIHZhciBzcGxpdERhdGEgPSBfYXJyYXkyWzBdLnNwbGl0KC9bXHNdKy8pOwoKICAgICAgcndsU3BsaXREYXRhLnB1c2goc3BsaXREYXRhKTsKICAgIH0gLy8gMykgYnVpbGQgbmV3IGhlYWRlcgogICAgLy8gaGVhZGVyIGZvcm1hdDogW1llYXIsIENvcmUgMSBuYW1lLCBDb3JlIDIgbmFtZSwgLi4uXQoKICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvcjIuZShlcnIpOwogIH0gZmluYWxseSB7CiAgICBfaXRlcmF0b3IyLmYoKTsKICB9CgogIHZhciBuZXdIZWFkZXIgPSBbJ1llYXInXTsKICB2YXIgY3VycmVudE5hbWUgPSAnJzsKCiAgZm9yICh2YXIgX2kgPSAwLCBfcndsU3BsaXREYXRhID0gcndsU3BsaXREYXRhOyBfaSA8IF9yd2xTcGxpdERhdGEubGVuZ3RoOyBfaSsrKSB7CiAgICB2YXIgYXJyYXkgPSBfcndsU3BsaXREYXRhW19pXTsKICAgIHZhciByb3dOYW1lID0gYXJyYXlbMF07CgogICAgaWYgKHJvd05hbWUgIT0gY3VycmVudE5hbWUgJiYgcm93TmFtZSkgewogICAgICBuZXdIZWFkZXIucHVzaChyb3dOYW1lKTsKICAgICAgY3VycmVudE5hbWUgPSByb3dOYW1lOwogICAgfQoKICAgIDsKICB9CgogIDsgLy8gNCkgY3JlYXRlIGFycmF5cyBmb3IgYWxsIHllYXJzCiAgLy8gZm9ybWF0OiBbWWVhciwgLi4uXSwgWzE5MDAsIC4uLl0sIFsxOTAxLCAuLi5dCgogIHZhciBlYXJsaWVzdFllYXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjsKICB2YXIgbGF0ZXN0RGVjYWRlID0gLTEgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjsKICB2YXIgbGF0ZXN0WWVhciA9IDA7CiAgdmFyIHJ3bERhdGExID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyd2xTcGxpdERhdGEpKTsgLy8gY3JlYXRlIG5ldyBhcnJheSBmb3IgZGF0YSBzbyBvbGQgb25lIGlzIG5vdCBtb2RpZmllZAoKICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJ3bERhdGExKSwKICAgICAgX3N0ZXAzOwoKICB0cnkgewogICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHsKICAgICAgdmFyIF9hcnJheTMgPSBfc3RlcDMudmFsdWU7CiAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoX2FycmF5M1sxXSk7CgogICAgICBpZiAoeWVhciA8IGVhcmxpZXN0WWVhcikgewogICAgICAgIC8vIGZpbmQgZmlyc3QgeWVhcgogICAgICAgIGVhcmxpZXN0WWVhciA9IHllYXI7CiAgICAgIH0gZWxzZSBpZiAoeWVhciA+IGxhdGVzdERlY2FkZSkgewogICAgICAgIC8vIGZpbmQgbGFzdCB5ZWFyCiAgICAgICAgX2FycmF5My5zcGxpY2UoMCwgMik7IC8vIHJlbW92ZSByb3cgbmFtZSAmIGRlY2FkZS95ZWFyCgoKICAgICAgICBfYXJyYXkzID0gX2FycmF5My5maWx0ZXIoZnVuY3Rpb24gKGUpIHsKICAgICAgICAgIC8vIHJlbW92ZSBzZW50aW5lbCwgc2VudGluZWwgPSBpbmRpY2F0b3Igb2Ygc3BlY2ltZW5zIGZpbmFsIHdpZHRoCiAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VGbG9hdChlKSkgPT0gZmFsc2UgJiYgcGFyc2VGbG9hdChlKSA+IDAgJiYgZSAhPSAnOTk5JykgewogICAgICAgICAgICByZXR1cm4gZTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICB2YXIgeWVhcnNfdG9fYWRkID0gX2FycmF5My5sZW5ndGggLSAxOyAvLyBhZGQgbnVtYmVyIG9mIHdpZHRocyB0byBmb3VuZCB5ZWFyLCBzdWJ0cmFjdCAxIGIvYyBSV0wgc3RhcnRzIGF0IDAgbm90IDEKCiAgICAgICAgbGF0ZXN0RGVjYWRlID0geWVhcjsKICAgICAgICBsYXRlc3RZZWFyID0geWVhciArIHllYXJzX3RvX2FkZDsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjMuZigpOwogIH0KCiAgZm9yICh2YXIgayA9IGVhcmxpZXN0WWVhcjsgayA8PSBsYXRlc3RZZWFyOyBrKyspIHsKICAgIHZhciBuZXdBcnJheSA9IFtdOwogICAgbmV3QXJyYXkucHVzaChTdHJpbmcoaykpOwogICAgZm9ybWF0dGVkRGF0YS5wdXNoKG5ld0FycmF5KTsKICB9IC8vIDUpIGZvcm1hdCAmIGFkZCB3aWR0aHMgdG8gZGF0YQogIC8vIGZvcm1hdDogW1llYXIsIENvcmUgMSBuYW1lLCBDb3JlIDIgbmFtZSwgLi4uXSwgWzE5MDAsIHdpZHRoIDEsIHdpZHRoIDIsIC4uLl0sIFsxOTAxLCB3aWR0aCAxLCB3aWR0aCAyLCAuLi5dCgoKICB2YXIgcndsRGF0YTIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJ3bFNwbGl0RGF0YSkpOyAvLyBjcmVhdGUgbmV3IGFycmF5IGZvciBkYXRhIHNvIG9sZCBvbmUgaXMgbm90IG1vZGlmaWVkCgogIHZhciBwcmV2X25hbWUgPSAnJzsKICB2YXIgbmV3U2V0ID0gdHJ1ZTsKCiAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyd2xEYXRhMiksCiAgICAgIF9zdGVwNDsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciByd2xBcnJheSA9IF9zdGVwNC52YWx1ZTsKICAgICAgdmFyIGN1cnJfbmFtZSA9IHJ3bEFycmF5WzBdOwoKICAgICAgaWYgKGN1cnJfbmFtZSA9PSBwcmV2X25hbWUpIHsKICAgICAgICBuZXdTZXQgPSBmYWxzZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBuZXdTZXQgPSB0cnVlOwogICAgICAgIHByZXZfbmFtZSA9IGN1cnJfbmFtZTsKICAgICAgfQoKICAgICAgdmFyIHN0YXJ0WWVhciA9IHBhcnNlRmxvYXQocndsQXJyYXlbMV0pOwogICAgICB2YXIgeWVhckFkaiA9IDA7IC8vIGluZGV4IG9mIHdpZHRoIGluIFJXTCBhcyB3ZWxsIGFzIHRoYXQgd2lkdGhzIHllYXIKCiAgICAgIHJ3bEFycmF5LnNwbGljZSgwLCAyKTsgLy8gcmVtb3ZlIHJvdyBuYW1lICYgZGVjYWRlL3llYXIKCiAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZm9ybWF0dGVkRGF0YSksCiAgICAgICAgICBfc3RlcDU7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgX2FycmF5NCA9IF9zdGVwNS52YWx1ZTsKICAgICAgICAgIHZhciB5ZWFyX2luX2Zvcm1hdHRlZERhdGEgPSBfYXJyYXk0WzBdOwoKICAgICAgICAgIGlmICh5ZWFyQWRqID4gcndsQXJyYXkubGVuZ3RoIC0gMSkgewogICAgICAgICAgICB5ZWFyQWRqID0gMDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgdmFyIHllYXJfaW5fcndsRGF0YSA9IFN0cmluZyhzdGFydFllYXIgKyB5ZWFyQWRqKTsKCiAgICAgICAgICBpZiAoeWVhcl9pbl9yd2xEYXRhID09IHllYXJfaW5fZm9ybWF0dGVkRGF0YSkgewogICAgICAgICAgICB2YXIgd2lkdGhfdG9fdGVzdCA9IHJ3bEFycmF5W3llYXJBZGpdOwoKICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQod2lkdGhfdG9fdGVzdCkpID09IGZhbHNlICYmIHBhcnNlRmxvYXQod2lkdGhfdG9fdGVzdCkgPiAwICYmIHdpZHRoX3RvX3Rlc3QgIT0gJzk5OScpIHsKICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IHdpZHRoIGlzIG5vdCBhIHNlbnRpbmVsIChpbmRpY2F0b3Igb2YgZW5kIG9mIGNvcmUpCiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdG9NTShyd2xBcnJheVt5ZWFyQWRqXSk7CgogICAgICAgICAgICAgIF9hcnJheTQucHVzaCh3aWR0aCk7CgogICAgICAgICAgICAgIHllYXJBZGorKzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAvLyBpZiBzZW50aW5lbCwgYWRkIC0xIChtaXNzaW5nIGRhdGEgaW5kaWNhdG9yKSB0byByZXN0IG9mIGZvcm1hdHRlZERhdGEKICAgICAgICAgICAgICB2YXIgY3VycmVudF9hcnJheV9pbmRleCA9IGZvcm1hdHRlZERhdGEuaW5kZXhPZihfYXJyYXk0KTsKCiAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IGN1cnJlbnRfYXJyYXlfaW5kZXg7IGwgPCBmb3JtYXR0ZWREYXRhLmxlbmd0aDsgbCsrKSB7CiAgICAgICAgICAgICAgICB2YXIgYXJyYXlfbmVlZGluZ19uZWdfb25lID0gZm9ybWF0dGVkRGF0YVtsXTsKICAgICAgICAgICAgICAgIGFycmF5X25lZWRpbmdfbmVnX29uZS5wdXNoKCctMScpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAobmV3U2V0ID09IHRydWUpIHsKICAgICAgICAgICAgX2FycmF5NC5wdXNoKCctMScpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7CiAgICAgIH0KICAgIH0gLy8gNikgYWRkIGhlYWRlcgoKICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvcjQuZShlcnIpOwogIH0gZmluYWxseSB7CiAgICBfaXRlcmF0b3I0LmYoKTsKICB9CgogIGZvcm1hdHRlZERhdGEudW5zaGlmdChuZXdIZWFkZXIpOwogIHJldHVybiBmb3JtYXR0ZWREYXRhOwp9CgpmdW5jdGlvbiBmb3JtYXRTcGFjZURlbGltKGRhdGEpIHsKICB2YXIgZm9ybWF0dGVkRGF0YSA9IFtdOwoKICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEpLAogICAgICBfc3RlcDY7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykgewogICAgICB2YXIgYXJyYXkgPSBfc3RlcDYudmFsdWU7CiAgICAgIHZhciBzcGxpdERhdGEgPSBhcnJheVswXS5zcGxpdCgvW1xzXSsvKTsKICAgICAgZm9ybWF0dGVkRGF0YS5wdXNoKHNwbGl0RGF0YSk7CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3I2LmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yNi5mKCk7CiAgfQoKICByZXR1cm4gZm9ybWF0dGVkRGF0YTsKfQoKZnVuY3Rpb24gcGFyc2VGaWxlKGZpbGUpIHsKICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgewogICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTsKCiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQsIGkpIHsKICAgICAgaWYgKGZpbGUudHlwZSA9PSAnYXBwbGljYXRpb24vanNvbicpIHsKICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UoZXZlbnQudGFyZ2V0LnJlc3VsdCkucHRXaWR0aHMpOwogICAgICB9IGVsc2UgewogICAgICAgIHZhciBwYXBhT2JqID0gUGFwYS5wYXJzZShldmVudC50YXJnZXQucmVzdWx0LCB7CiAgICAgICAgICBkZWxpbWl0ZXJzVG9HdWVzczogWycsJywgJ1x0J10KICAgICAgICB9KTsKCiAgICAgICAgaWYgKHBhcGFPYmouZXJyb3JzLmxlbmd0aCkgewogICAgICAgICAgLy8gcndsIG9yIHNwYWNlIGRlbWlsaXRlZCBmaWxlcwogICAgICAgICAgLy8gc3BhY2UgZGVsaW1pdGVkIGhhcyBhIHllYXJzIGluIGZhciBsZWZ0IGNvbHVtbiwgUldMIGhhZCBzcGVjaW1lbiBuYW1lcywgd2F5IHRvIGRpZmZlcmVudGlhdGUKICAgICAgICAgIHZhciBzcGxpdF9zZWNvbmRfcm93ID0gcGFwYU9iai5kYXRhWzFdWzBdLnNwbGl0KC9bXHNdKy8pOwogICAgICAgICAgdmFyIHRlc3Rfc3RyaW5nID0gc3BsaXRfc2Vjb25kX3Jvd1swXTsKCiAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VGbG9hdCh0ZXN0X3N0cmluZykpKSB7CiAgICAgICAgICAgIHJlc29sdmUoZm9ybWF0UldMKHBhcGFPYmouZGF0YSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzb2x2ZShmb3JtYXRTcGFjZURlbGltKHBhcGFPYmouZGF0YSkpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBDU1YsIFRTViBmaWxlcwogICAgICAgICAgcmVzb2x2ZShwYXBhT2JqLmRhdGEpOwogICAgICAgIH0KICAgICAgfQogICAgfTsKCiAgICBmci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikgewogICAgICByZXR1cm4gcmVqZWN0KGVycik7CiAgICB9OwoKICAgIGZyLnJlYWRBc1RleHQoZmlsZSk7CiAgfSk7Cn0KCmZ1bmN0aW9uIHBhcnNlRmlsZXMoX3gpIHsKICByZXR1cm4gX3BhcnNlRmlsZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKfQoKZnVuY3Rpb24gX3BhcnNlRmlsZXMoKSB7CiAgX3BhcnNlRmlsZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGZpbGVzKSB7CiAgICB2YXIgcGFyc2VkRmlsZXMsIF9pdGVyYXRvcjgsIF9zdGVwOCwgZmlsZSwgcGFyc2VkRmlsZSwgZmlsZU9iajsKCiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0MikgewogICAgICB3aGlsZSAoMSkgewogICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICBwYXJzZWRGaWxlcyA9IFtdOwogICAgICAgICAgICBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZmlsZXMpOwogICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI7CgogICAgICAgICAgICBfaXRlcmF0b3I4LnMoKTsKCiAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgIGlmICgoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmUpIHsKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CgogICAgICAgICAgICBmaWxlID0gX3N0ZXA4LnZhbHVlOwogICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDg7CiAgICAgICAgICAgIHJldHVybiBwYXJzZUZpbGUoZmlsZSk7CgogICAgICAgICAgY2FzZSA4OgogICAgICAgICAgICBwYXJzZWRGaWxlID0gX2NvbnRleHQyLnNlbnQ7CgogICAgICAgICAgICBpZiAocGFyc2VkRmlsZS50dykgewogICAgICAgICAgICAgIHBhcnNlZEZpbGUudHcuZmlsZU5hbWUgPSBmaWxlLm5hbWU7CgogICAgICAgICAgICAgIGlmIChwYXJzZWRGaWxlLmV3ICYmIHBhcnNlZEZpbGUubHcpIHsKICAgICAgICAgICAgICAgIHBhcnNlZEZpbGUuZXcuZmlsZU5hbWUgPSBmaWxlLm5hbWU7CiAgICAgICAgICAgICAgICBwYXJzZWRGaWxlLmx3LmZpbGVOYW1lID0gZmlsZS5uYW1lOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBmaWxlT2JqID0gbmV3IE9iamVjdCgpOwogICAgICAgICAgICAgIGZpbGVPYmouZmlsZU5hbWUgPSBmaWxlLm5hbWU7CiAgICAgICAgICAgICAgZmlsZU9iai5kYXRhID0gcGFyc2VkRmlsZTsKICAgICAgICAgICAgICBwYXJzZWRGaWxlID0gZmlsZU9iajsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcGFyc2VkRmlsZXMucHVzaChwYXJzZWRGaWxlKTsKCiAgICAgICAgICBjYXNlIDExOgogICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7CiAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7CiAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgIGNhc2UgMTU6CiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTU7CiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MlsiY2F0Y2giXSgyKTsKCiAgICAgICAgICAgIF9pdGVyYXRvcjguZShfY29udGV4dDIudDApOwoKICAgICAgICAgIGNhc2UgMTg6CiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTg7CgogICAgICAgICAgICBfaXRlcmF0b3I4LmYoKTsKCiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDE4KTsKCiAgICAgICAgICBjYXNlIDIxOgogICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgicmV0dXJuIiwgcGFyc2VkRmlsZXMpOwoKICAgICAgICAgIGNhc2UgMjI6CiAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzIsIDE1LCAxOCwgMjFdXSk7CiAgfSkpOwogIHJldHVybiBfcGFyc2VGaWxlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwp9Cgp2YXIgZm9ybWF0RmlsZURhdGEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGZpbGVzKSB7CiAgICB2YXIgZmlsZURhdGFBcnJheSwgYXJyLCBfaXRlcmF0b3I3LCBfc3RlcDcsIGZpbGVEYXRhLCBjb2wsIHllYXJBcnJheSwgd2lkdGhBcnJheSwgcm93LCB5ZWFyLCB3aWR0aCwgb2JqOwoKICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkgewogICAgICB3aGlsZSAoMSkgewogICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7CiAgICAgICAgICAgIHJldHVybiBwYXJzZUZpbGVzKGZpbGVzKTsKCiAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgIGZpbGVEYXRhQXJyYXkgPSBfY29udGV4dC5zZW50OwogICAgICAgICAgICBhcnIgPSBuZXcgQXJyYXkoKTsKICAgICAgICAgICAgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpbGVEYXRhQXJyYXkpOwogICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNTsKCiAgICAgICAgICAgIF9pdGVyYXRvcjcucygpOwoKICAgICAgICAgIGNhc2UgNzoKICAgICAgICAgICAgaWYgKChfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZSkgewogICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZmlsZURhdGEgPSBfc3RlcDcudmFsdWU7CgogICAgICAgICAgICBpZiAoIWZpbGVEYXRhLnR3KSB7CiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBKU09OIGFscmVhZHkgZm9ybWF0dGVkCiAgICAgICAgICAgIGFyci5wdXNoKGZpbGVEYXRhLnR3KTsKCiAgICAgICAgICAgIGlmIChmaWxlRGF0YS5ldyAmJiBmaWxlRGF0YS5sdykgewogICAgICAgICAgICAgIGFyci5wdXNoKGZpbGVEYXRhLmV3KTsKICAgICAgICAgICAgICBhcnIucHVzaChmaWxlRGF0YS5sdyk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoImNvbnRpbnVlIiwgMTQpOwoKICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgIC8qIG90aGVyIGZpbGUgdHlwZXMgYXJlIGZvcm1hdHRlZDoNCiAgICAgICAgICAgICAgW3llYXIsIG5hbWVBLCBuYW1lQiwgLi4uXSwNCiAgICAgICAgICAgICAgW3llYXIxLCB3aWR0aDFBLCB3aWR0aDFCLCAuLi5dLA0KICAgICAgICAgICAgICAgIGNvbnZlcnQgaXQgdG8gUGxvdGx5IGRhdGEgb2JqZWN0IGZvcm1hdDoNCiAgICAgICAgICAgICAgb2JqID0gew0KICAgICAgICAgICAgICAgIHg6IFsuLi5dLCAoeWVhcnMpDQogICAgICAgICAgICAgICAgeTogWy4uLl0sICh3aWR0aHMpDQogICAgICAgICAgICAgICAgbmFtZTogJ25hbWVBJywNCiAgICAgICAgICAgICAgICAuLi4NCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgKi8KICAgICAgICAgICAgZm9yIChjb2wgPSAxOyBjb2wgPCBmaWxlRGF0YS5kYXRhWzBdLmxlbmd0aDsgY29sKyspIHsKICAgICAgICAgICAgICB5ZWFyQXJyYXkgPSBbXTsKICAgICAgICAgICAgICB3aWR0aEFycmF5ID0gW107CgogICAgICAgICAgICAgIGZvciAocm93ID0gMTsgcm93IDwgZmlsZURhdGEuZGF0YS5sZW5ndGg7IHJvdysrKSB7CiAgICAgICAgICAgICAgICB5ZWFyID0gZmlsZURhdGEuZGF0YVtyb3ddWzBdOwogICAgICAgICAgICAgICAgd2lkdGggPSBmaWxlRGF0YS5kYXRhW3Jvd11bY29sXTsKCiAgICAgICAgICAgICAgICBpZiAod2lkdGggPj0gMCkgewogICAgICAgICAgICAgICAgICB5ZWFyQXJyYXkucHVzaChwYXJzZUludCh5ZWFyKSk7CiAgICAgICAgICAgICAgICAgIHdpZHRoQXJyYXkucHVzaChwYXJzZUZsb2F0KHdpZHRoKSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBvYmogPSBuZXcgT2JqZWN0KCk7CiAgICAgICAgICAgICAgb2JqLm5hbWUgPSBmaWxlRGF0YS5kYXRhWzBdW2NvbF07CiAgICAgICAgICAgICAgb2JqLmZpbGVOYW1lID0gZmlsZURhdGEuZmlsZU5hbWU7CiAgICAgICAgICAgICAgb2JqLnggPSB5ZWFyQXJyYXk7CiAgICAgICAgICAgICAgb2JqLnkgPSB3aWR0aEFycmF5OwogICAgICAgICAgICAgIGFyci5wdXNoKG9iaik7CiAgICAgICAgICAgIH0KCiAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNzsKICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxOwogICAgICAgICAgICBicmVhazsKCiAgICAgICAgICBjYXNlIDE4OgogICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTg7CiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbImNhdGNoIl0oNSk7CgogICAgICAgICAgICBfaXRlcmF0b3I3LmUoX2NvbnRleHQudDApOwoKICAgICAgICAgIGNhc2UgMjE6CiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMTsKCiAgICAgICAgICAgIF9pdGVyYXRvcjcuZigpOwoKICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyMSk7CgogICAgICAgICAgY2FzZSAyNDoKICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgYXJyKTsKCiAgICAgICAgICBjYXNlIDI1OgogICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbNSwgMTgsIDIxLCAyNF1dKTsKICB9KSk7CgogIHJldHVybiBmdW5jdGlvbiBmb3JtYXRGaWxlRGF0YShfeDIpIHsKICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgfTsKfSgpOwoKZXhwb3J0IGRlZmF1bHQgZm9ybWF0RmlsZURhdGE7"},{"version":3,"sources":["C:/Users/JThorneUMN/Documents/GitHub/dendro-plots/src/modules/formatFileData.js"],"names":["Papa","toMM","num","length","slice","formatRWL","data","formattedData","headerLength","array","test_character","charAt","isNaN","parseFloat","splice","rwlSplitData","splitData","split","push","newHeader","currentName","rowName","earliestYear","Number","MAX_SAFE_INTEGER","latestDecade","latestYear","rwlData1","JSON","parse","stringify","year","parseInt","filter","e","years_to_add","k","newArray","String","rwlData2","prev_name","newSet","rwlArray","curr_name","startYear","yearAdj","year_in_formattedData","year_in_rwlData","width_to_test","width","current_array_index","indexOf","l","array_needing_neg_one","unshift","formatSpaceDelim","parseFile","file","Promise","resolve","reject","fr","FileReader","onload","event","i","type","target","result","ptWidths","papaObj","delimitersToGuess","errors","split_second_row","test_string","onerror","err","readAsText","parseFiles","files","parsedFiles","parsedFile","tw","fileName","name","ew","lw","fileObj","Object","formatFileData","fileDataArray","arr","Array","fileData","col","yearArray","widthArray","row","obj","x","y"],"mappings":"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","sourcesContent":["// parse local core points in LTreering\r\n// window.postMessage({ x: [], y: [], name: \"\" })\r\n\r\n// use distance & annotation data in JSON\r\n\r\nimport Papa from 'papaparse'\r\n\r\nfunction toMM (num) {\r\n  if (num.length == 4) {\r\n    // 1234 => 1.234\r\n    return num.slice(0, 1) + '.' + num.slice(1);\r\n  } else if (num.length == 3) {\r\n    // 123 => 0.123\r\n    return '0.' + num\r\n  } else if (num.length == 2) {\r\n    // 12 => 0.012\r\n    return '0.0' + num\r\n  } else {\r\n    // 1 => 0.001\r\n    return '0.00' + num\r\n  }\r\n}\r\n\r\nfunction formatRWL (data) {\r\n  var formattedData = [];\r\n  // 1) rwl remove header\r\n  var headerLength = 0\r\n  for (let array of data) {\r\n    let test_character = array[0].charAt(9)\r\n    if (isNaN(parseFloat(test_character))) {\r\n      headerLength++\r\n    } else {\r\n      break\r\n    }\r\n  }\r\n  data.splice(0, headerLength);\r\n  // 2) split rwl data into array\r\n  // current format: [Core name, year, length, length, length, ...], ...\r\n  var rwlSplitData = []\r\n  for (let array of data) {\r\n    var splitData = array[0].split(/[\\s]+/)\r\n    rwlSplitData.push(splitData)\r\n  }\r\n  // 3) build new header\r\n  // header format: [Year, Core 1 name, Core 2 name, ...]\r\n  var newHeader = ['Year'];\r\n  var currentName = '';\r\n  for (let array of rwlSplitData) {\r\n    let rowName = array[0];\r\n    if (rowName != currentName && rowName) {\r\n      newHeader.push(rowName);\r\n      currentName = rowName;\r\n    };\r\n  };\r\n  // 4) create arrays for all years\r\n  // format: [Year, ...], [1900, ...], [1901, ...]\r\n  var earliestYear = Number.MAX_SAFE_INTEGER;\r\n  var latestDecade =  -1 * Number.MAX_SAFE_INTEGER;\r\n  var latestYear = 0;\r\n  var rwlData1 = JSON.parse(JSON.stringify(rwlSplitData)); // create new array for data so old one is not modified\r\n  for (let array of rwlData1) {\r\n    var year = parseInt(array[1]);\r\n    if (year < earliestYear) { // find first year\r\n      earliestYear = year;\r\n    } else if (year > latestDecade) { // find last year\r\n      array.splice(0, 2) // remove row name & decade/year\r\n      array = array.filter((e) => { // remove sentinel, sentinel = indicator of specimens final width\r\n        if ((isNaN(parseFloat(e)) == false) &&\r\n        (parseFloat(e) > 0) &&\r\n        (e != '999')) {\r\n          return e\r\n        }\r\n      });\r\n      var years_to_add = array.length - 1; // add number of widths to found year, subtract 1 b/c RWL starts at 0 not 1\r\n      latestDecade = year;\r\n      latestYear = year + years_to_add;\r\n    }\r\n  }\r\n  for (var k = earliestYear; k <= latestYear; k++) {\r\n    var newArray = [];\r\n    newArray.push(String(k));\r\n    formattedData.push(newArray);\r\n  }\r\n  // 5) format & add widths to data\r\n  // format: [Year, Core 1 name, Core 2 name, ...], [1900, width 1, width 2, ...], [1901, width 1, width 2, ...]\r\n  var rwlData2 = JSON.parse(JSON.stringify(rwlSplitData)); // create new array for data so old one is not modified\r\n  var prev_name = '';\r\n  var newSet = true;\r\n  for (let rwlArray of rwlData2) {\r\n    var curr_name = rwlArray[0];\r\n    if (curr_name == prev_name) {\r\n      newSet = false;\r\n    } else {\r\n      newSet = true;\r\n      prev_name = curr_name;\r\n    }\r\n\r\n    var startYear = parseFloat(rwlArray[1]);\r\n    var yearAdj = 0; // index of width in RWL as well as that widths year\r\n    rwlArray.splice(0, 2); // remove row name & decade/year\r\n    for (let array of formattedData) {\r\n      var year_in_formattedData = array[0];\r\n      if (yearAdj > rwlArray.length - 1) {\r\n        yearAdj = 0;\r\n        break\r\n      }\r\n      var year_in_rwlData = String(startYear + yearAdj);\r\n      if (year_in_rwlData == year_in_formattedData) {\r\n        var width_to_test = rwlArray[yearAdj];\r\n        if ((isNaN(parseFloat(width_to_test)) == false) &&\r\n            (parseFloat(width_to_test) > 0) &&\r\n            (width_to_test != '999')) {\r\n          // check that width is not a sentinel (indicator of end of core)\r\n          var width = toMM(rwlArray[yearAdj])\r\n          array.push(width);\r\n          yearAdj++\r\n        } else { // if sentinel, add -1 (missing data indicator) to rest of formattedData\r\n          var current_array_index = formattedData.indexOf(array);\r\n          for (var l = current_array_index; l < formattedData.length; l++) {\r\n            var array_needing_neg_one = formattedData[l];\r\n            array_needing_neg_one.push('-1');\r\n          }\r\n          break\r\n        }\r\n      } else if (newSet == true) {\r\n        array.push('-1')\r\n      }\r\n    }\r\n  }\r\n  // 6) add header\r\n  formattedData.unshift(newHeader);\r\n\r\n  return formattedData\r\n}\r\n\r\nfunction formatSpaceDelim (data) {\r\n  var formattedData = []\r\n  for (let array of data) {\r\n    let splitData = array[0].split(/[\\s]+/)\r\n    formattedData.push(splitData)\r\n  }\r\n\r\n  return formattedData\r\n}\r\n\r\nfunction parseFile (file) {\r\n  return new Promise((resolve, reject) => {\r\n    let fr = new FileReader()\r\n    fr.onload = function(event, i) {\r\n      if (file.type == 'application/json') {\r\n        resolve(JSON.parse(event.target.result).ptWidths)\r\n      } else {\r\n        let papaObj = Papa.parse(event.target.result, {delimitersToGuess: [',', '\\t']})\r\n        if (papaObj.errors.length) { // rwl or space demilited files\r\n          // space delimited has a years in far left column, RWL had specimen names, way to differentiate\r\n          var split_second_row = papaObj.data[1][0].split(/[\\s]+/);\r\n          var test_string = split_second_row[0];\r\n          if (isNaN(parseFloat(test_string))) {\r\n            resolve(formatRWL(papaObj.data))\r\n          } else {\r\n            resolve(formatSpaceDelim(papaObj.data))\r\n          }\r\n        } else { // CSV, TSV files\r\n          resolve(papaObj.data)\r\n        }\r\n      }\r\n    }\r\n    fr.onerror = err => reject(err);\r\n\r\n    fr.readAsText(file)\r\n  })\r\n}\r\n\r\nasync function parseFiles(files) {\r\n  var parsedFiles = [];\r\n\r\n  for (let file of files) {\r\n    let parsedFile = await parseFile(file)\r\n    if (parsedFile.tw) {\r\n      parsedFile.tw.fileName = file.name\r\n      if (parsedFile.ew && parsedFile.lw) {\r\n        parsedFile.ew.fileName = file.name\r\n        parsedFile.lw.fileName = file.name\r\n      }\r\n    } else {\r\n      let fileObj = new Object();\r\n      fileObj.fileName = file.name\r\n      fileObj.data = parsedFile\r\n      parsedFile = fileObj\r\n    }\r\n    parsedFiles.push(parsedFile)\r\n  }\r\n\r\n  return parsedFiles\r\n}\r\n\r\nconst formatFileData = async function (files) {\r\n  var fileDataArray = await parseFiles(files)\r\n\r\n  var arr = new Array()\r\n\r\n  for (let fileData of fileDataArray) {\r\n    if (fileData.tw) { // JSON already formatted\r\n      arr.push(fileData.tw)\r\n      if (fileData.ew && fileData.lw) {\r\n        arr.push(fileData.ew)\r\n        arr.push(fileData.lw)\r\n      }\r\n      continue\r\n    }\r\n\r\n    /* other file types are formatted:\r\n      [year, nameA, nameB, ...],\r\n      [year1, width1A, width1B, ...],\r\n\r\n      convert it to Plotly data object format:\r\n      obj = {\r\n        x: [...], (years)\r\n        y: [...], (widths)\r\n        name: 'nameA',\r\n        ...\r\n      }\r\n    */\r\n    for (let col = 1; col < fileData.data[0].length; col++) {\r\n      var yearArray = []\r\n      var widthArray = []\r\n      for (let row = 1; row < fileData.data.length; row++) {\r\n        let year = fileData.data[row][0]\r\n        let width = fileData.data[row][col]\r\n        if (width >= 0) {\r\n          yearArray.push(parseInt(year))\r\n          widthArray.push(parseFloat(width))\r\n        }\r\n      }\r\n      var obj = new Object()\r\n      obj.name = fileData.data[0][col]\r\n      obj.fileName = fileData.fileName\r\n      obj.x = yearArray\r\n      obj.y = widthArray\r\n\r\n      arr.push(obj)\r\n    }\r\n  }\r\n  return arr\r\n}\r\n\r\nexport default formatFileData\r\n"]}]}